# 廖雪峰的练习道具

## 学习教程

http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000

---------------

## 在线学习器

需要在自己的机器上启动 tools/learning.py

# 打印

内容见/scripts/print.py

* print输出多个字符串的时候，每个中间有空格
* 输入使用input()

# Python基础

内容见/scripts/practice1.py

* Python是大小写敏感
* 缩进类型最好用4个空格(我还是喜欢用tab)
* 数据类型：整数，浮点，字符串
* 如果字符串不需要转义，则用 r"不转义的字符，需要在字符前面加上'r'"
* 布尔值 True False,逻辑运算符为 and , or , not
* 空值为 None
* Python 语言为动态类型语言
* 一般用全部大写表示常量（虽然Python并无常量概念）
* _*重点：除法（/）的结果始终是浮点数*_ _这是在python3下_  _python2下，整数能整除的时候，结果是int_
* _*重点：地板除法（//）的结果始终是取整，但是数据类型依然是浮点数*_ 
* _*重点：python对整数大小没有限制*_
* _*重点：python对浮点数大小没有限制，但超过一定大小就表示为inf*_

# 字符编码

内容见/scripts/encoding.py

* utf编码为unicode通过转换而来的变长编码格式，utf编码格式可以兼容ascii
* 在计算机的内存中，存储的为unicode编码，在传输和保存的时候，会转化为utf编码（或者其他编码）
* Python3中 取消了u，所有字符用unicode形式存储，用ord()查看编码，chr()转化为字符串
* 用十六进制编码表示字符串，可用转义符 _*\u + 十六进制编码*_ 例如 '\u4e2d\u6587' 
* 用字节形式保存字符串则在字符串前加上b 例如 b'abc' ，注意只对ascii字符有效，我们在对非ascii字符 byte化的时候需要选择编码类型用字符串的.encode(编码格式) 来处理，得到一个 bytes类型，也就是说，b'abc'其实也等价于 'abc'.encode('ascii')
* 读取字节流后，需解码为unicode，用.decode(编码) 来实现，如编码参数不正确不匹配，则可能出现乱码
* #!/usr/bin/env python3 表示linux等系统下，是一个python3可执行程序，在文件开头一般加上这个
* #-*- coding: utf-8 -*- 表示存储文件的编码格式,解释器在读取文件的时候，会使用这个编码加载，否则可能出现非ascii不正确的情况，_*注意一旦申明了使用的编码，那么保存文件的时候必须保存为相应编码的文件，例如申明utf-8必须保存为utf-8无bom*_
* 字符串格式化方式用% 例如 _*'Hi, %s, you have $%d.' % ('Michael', 1000000)*_
* 格式化类型 d 整数  f 浮点数  s 字符串  x十六进制整数 
* 数字可以格式化位数，如 _*'%2d-%02d' % (3, 1)        '%.2f' % 3.1415926*_   
* %%表示转义%
* 没事别找事用utf-8外的编码，除非特殊需求
* len(字符串) 表示字符数 len(byte类型) 表示 byte数

# 容器

内容见/scripts/container.py

## list 列表

* 列表为list，列表有序，用方括号表示
* len(list) 表示元素个数
* 用方括号加下标访问元素，下标从0开始
* 用负数下标表示倒数第几个元素 例如  a[-2] 表示倒数第二个元素
* 用append追加到最后一个元素
* 用insert插入到指定位置 如 _*a.insert(1,'Jack')*_
* 用pop取出并去掉最后一个元素，pop加上参数表示退出第几个元素
* 直接对下标元素操作赋值可以替换他的值，但是不能对不存在的元素赋值（不能超过下标来赋值）

## tuple 元组

* 元组用小括号表示
* 元组初始化之后不可修改，即没有insert pop append等函数，其他同list
* 如果要定义只有一个元素的元组，一定要在第一个元素后加逗号，避免python把小括号当作逻辑运算符，打印只有一个元素的tuple时候，python也会加上逗号，避免歧义
* 元组内容不变，指的是里面的每个元素引用不变，不代表里面元素引用的内容不能改变

## dict 字典

* 字典用大括号表示 例如 _*{1:40,'map':'42',True:123}*_
* 用key来取元素，可以直接用新的key赋值到字典中，但是不能取不存在value的key，会触发keyError
* 可以用in逻辑符来判断是否存在key ，或者用 字典.get(key,默认返回) 的方式取元素，如果参数不加默认返回，则返回None
* 用pop来退出一个元素
* key要为一个不可变对象，否则哈希就无法工作了
> _*这里有一个重点，在python中 True 和 1 等价 False 和 0 等价，所以 a[1] 和 a[True] 等价 （注意是等价，不是相等，因为数据类型不同）*_


## set 

* set是无重复元素集合，set是无序的
* set用 set() 传入一个list来构建，单会过滤掉list中重复的元素，例如：
> s = set([1,2,3])  
> s1 = set([1,2,3,3])  
> 两者都会得到set {1,2,3}  
* 用 add() 为set添加元素 重复的不会被添加
* 用 remove() 去掉元素
* 因为set无序不重复，所以可以使用交并等操作 python 中 交为 & 并为 | (很多时候做算法用到这个)

## 关于可变和不可变对象的问题

* Python中的字符串类型不可变，其实是机制和Java中类似的，重新赋值会改变引用，而调用str2.replace() 等不会改变 str2的引用内容，只会返回一个新的字符串的引用，所以原字符串是不变的
* Python中的list可变，指的是list变量指向的list内容在list引用不变的情况下是可能变化的，比如list1.sort()返回的值任然是list1的引用，但里面的元素已经排序过了
* 不可变的内容，才是可哈西的，注意：
> 哈西一样的元素在set和dic的key中，是不会重复的，例如上面说的 True和1 False和0

## 字典补充

内容见/scripts/moreInDic.py

* 用 keys()取得dic的keyset
* 用 values()取得dic的values
* 都是 iterable
* 同时迭代 key和value 用 for k,v in dic.items()

## 条件判断和循环

内容见/scripts/conditionAndLoop.py

*  写法如下 
> if con:  
> &nbsp;&nbsp;statement1  
> elif con2:  
> &nbsp;&nbsp;statement2  
> else:  
> &nbsp;&nbsp;statement3  
* con 可以简写 如果是 非零数 非空字符串 非空 list 则为 True 否则 False （各种空类型，都是False）详见练习代码
* 和大多数语言一样，一个条件为True了，不会执行后面的条件检查

* 循环语法是 for ele in 容器
* range()函数可以生成一个整数序列 例如 range(3) 返回一个range对象，从0到2的序列，range对象可以list()转型，range接受两个参数的时候为头和until
* 遍历和循环一样的玩法，可以遍历list range set dic ，无序容器的遍历也是无序的,遍历dic的时候，是遍历的dic的keyset
* while循环，语法是 while con:
* break可以退出循环
* continue可以跳到下个循环
* 任何iterable的都可以遍历（这不是废话吗）
* 判断是否可遍历，使用对象是否是 Iterable  isinstance(obj,Iterable) 
* enumerate 是 python3 的函数 可以把iterable 返回成 index,value形式 ，注意对dic操作，和遍历dic一样，只会对dict的keyset进行处理
* 记住常见的用法 for x, y in [(1, 1), (2, 4), (3, 9)]:

# 函数

内容见/scripts/functions.py

* 可以通过help函数查看函数帮助，后面的函数不明白的都可以用max
* max 从一串参数或一个容器(不一定是容器，也可以是iterable)中返回最大值 , 必须全部内容都可以比较大小 str 和 int 就不能比较
* abs 绝对值
* 数据类型转换 int() float() str() bool()
* 函数名也是一个引用，可以赋给其他变量,所以没错，你也可以把函数名这个引用指向其他东西，比如 print ＝ 123
* 可以利用上面的机制来重新封装内置函数，详见代码

* 用def定义函数 def 函数名(参数表):
* return 退出函数，加上返回值，如果没有返回值则为None，可以返回多个值，返回的是一个元表
* 用pass表示空语句，避免没有代码块时的缩进问题
* 参数个数必须和定义一致，参数类型必须和定义一致，传参按照参数表的顺序
* isinstance() 用来检查数据类型，接受一个class类型参数，或者一个类型元表
* 参数表中可以用 x=y 代表 x参数不传值的时候默认为y ,把有默认值的参数放在 参数表中没有默认值的参数的后面（自己想想为什么）
* 函数接受了所有非默认值参数后就可以通过参数检查，后面的参数在传的之后可通过 x＝y来传，而不必按顺序 详见练习代码
* 默认参数的坑：默认参数是一个在函数定义的时候加入内存的变量，如果他是一个可变的，则会出现默认参数发生变化的问题（是不是有点像闭包），所以默认参数，在不玩花样的情况下，应当使用不变对象
* 可变参数，tuple用一个*表示，dic则用**表示 ，传参的时候，也可以在list或者tuple前加上*表示传入可变参数
* #dic参数不能和参数表中其他的参数名称一样
* 参数表顺序必须是 必选参数、默认参数、可变参数、关键字参数 否则会语法错误
* 我用可以用func(*args,**kw)来调用任何函数，填满定义函数的参数表的方式是，先 必须参数 ，再用*args填可选参数，如果args填满了可选参数，多余的args会填入函数的可变参数，则kw会填函数的关键字参数，如果args没有填满可选参数，那么如果args中有可变参数同名，则会填该可选参数，剩下的填入函数的关键字参数。 参数表，可变参数，关键字参数重复的时候，会报错。

* 使用递归函数的时候，要注意递归次数过多导致栈溢出，需要进行尾递归优化
* 尾递归优化：尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
* 然后Python没有尾递归优化，所以代码就不写了

# 高级特性

内容见/scripts/enterprise.py

* 切片是对iterable取片段的操作 [0:3] 表示 0 until 3 的元素 0 可以省略 [:3] , [-2:] 表示 倒数第二个起取完 ，第二个:后面表示的是取元素间隔 [10:20:2] 这里的2表示每2个元素取一个 [:] 可以复制一个同样 有序对象
* 元组切片后得到的对象还是元组
* 字符串切片后的对象仍然是字符串
* 由于元组和字符串机制相同的，所以复制一个一样的元组和字符串，不会生成新对象，只会新增一个指向原对象的引用

## List Comprehensions 列表生成